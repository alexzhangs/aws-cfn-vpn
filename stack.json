{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "AWS CloudFormation Template to create VPN services, contains 1 EC2 instance, 1 EIP and 1 security group. Also contains a nested template to create VPC reources.",
  "Resources": {
    "VpcStack": {
      "Type": "AWS::CloudFormation::Stack",
      "Properties": {
        "TemplateURL": {"Ref": "VpcStackTemplateURL"},
        "Parameters": {
          "VpcCidrBlock": {"Ref": "VpcCidrBlock"},
          "SubnetCidrBlocks": {"Fn::Join": [",", {"Ref": "SubnetCidrBlocks"}]}
        },
        "TimeoutInMinutes": "2"
      }
    },
    "VpcPeerAccepterStack": {
      "Type": "AWS::CloudFormation::Stack",
      "Condition": "EnableVpcPeerAccepter",
      "Properties": {
        "TemplateURL": {"Ref": "VpcPeerAccepterStackTemplateURL"},
        "Parameters": {
          "RouteTableId": {"Fn::GetAtt": ["VpcStack", "Outputs.PublicRouteTable"]}
        },
        "TimeoutInMinutes": "2"
      }
    },
    "VpcPeerRequesterStack": {
      "Type": "AWS::CloudFormation::Stack",
      "Condition": "EnableVpcPeerRequester",
      "Properties": {
        "TemplateURL": {"Ref": "VpcPeerRequesterStackTemplateURL"},
        "Parameters": {
          "VpcId": {"Fn::GetAtt": ["VpcStack", "Outputs.Vpc"]},
          "CidrBlock": {"Ref": "VpcCidrBlock"},
          "RouteTableId": {"Fn::GetAtt": ["VpcStack", "Outputs.PublicRouteTable"]},
          "PeeringVpcId": {"Ref": "VpcPeerAccepterVpcId"},
          "PeeringRegion": {"Ref": "VpcPeerAccepterRegion"},
          "PeeringAccountId": {"Ref": "SSMAccountId"},
          "PeeringRoleArn": {"Ref": "VpcPeerAccepterRoleArn"},
          "PeeringCidrBlock": {"Ref": "VpcPeerAccepterCidrBlock"},
          "PeeringSqsQueueUrl": {"Ref": "VpcPeerAccepterSqsQueueUrl"}
        },
        "TimeoutInMinutes": "3"
      }
    },
    "ConfigProviderStack": {
      "Type": "AWS::CloudFormation::Stack",
      "Condition": "EnableConfigProvider",
      "Properties": {
        "TemplateURL": {"Ref": "ConfigProviderStackTemplateURL"},
        "Parameters": {
          "AllSupported": "false",
          "IncludeGlobalResourceTypes": "false",
          "ResourceTypes": "AWS::EC2::Instance",
          "SnsTopicArn": {"Fn::If": [
            "EnableConfigConsumer",
            {"Ref": "SnsTopicForConfig"},
            {"Ref": "SnsTopicArn"}
          ]}
        },
        "TimeoutInMinutes": "2"
      }
    },
    "LexBotStack": {
      "Type": "AWS::CloudFormation::Stack",
      "Condition": "EnableLexBot",
      "Properties": {
        "TemplateURL": {"Ref": "LexBotStackTemplateURL"},
        "Parameters": {
          "Region": {"Ref": "LexBotRegion"},
          "LambdaArn": {"Fn::GetAtt": ["LambdaLexBot", "Arn"]}
        },
        "TimeoutInMinutes": "2"
      }
    },
    "VPNServerSG": {
      "Type": "AWS::EC2::SecurityGroup",
      "Properties": {
        "GroupDescription": "VPN server security group",
        "VpcId": {"Fn::GetAtt": ["VpcStack", "Outputs.Vpc"]},
        "SecurityGroupIngress": [
          {
            "IpProtocol": "tcp",
            "FromPort": "22",
            "ToPort": "22",
            "CidrIp": "0.0.0.0/0"
          }
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": {"Fn::Sub": "${AWS::StackName}-VPNServerSG"}
          }
        ]
      }
    },
    "L2TPIKEIngress": {
      "Type": "AWS::EC2::SecurityGroupIngress",
      "Condition": "EnableL2TP",
      "Properties": {
        "IpProtocol": "udp",
        "FromPort": 500,
        "ToPort": 500,
        "CidrIp": "0.0.0.0/0",
        "GroupId": {"Fn::GetAtt": ["VPNServerSG", "GroupId"]}
      }
    },
    "L2TPNATIngress": {
      "Type": "AWS::EC2::SecurityGroupIngress",
      "Condition": "EnableL2TP",
      "Properties": {
        "IpProtocol": "udp",
        "FromPort": 4500,
        "ToPort": 4500,
        "CidrIp": "0.0.0.0/0",
        "GroupId": {"Fn::GetAtt": ["VPNServerSG", "GroupId"]}
      }
    },
    "SSTCPIngress": {
      "Type": "AWS::EC2::SecurityGroupIngress",
      "Condition": "EnableSSN",
      "Properties": {
        "IpProtocol": "tcp",
        "FromPort": {"Ref": "SSPortBegin"},
        "ToPort": {"Ref": "SSPortEnd"},
        "CidrIp": "0.0.0.0/0",
        "GroupId": {"Fn::GetAtt": ["VPNServerSG", "GroupId"]}
      }
    },
    "SSUDPIngress": {
      "Type": "AWS::EC2::SecurityGroupIngress",
      "Condition": "EnableSSN",
      "Properties": {
        "IpProtocol": "udp",
        "FromPort": {"Ref": "SSPortBegin"},
        "ToPort": {"Ref": "SSPortEnd"},
        "CidrIp": "0.0.0.0/0",
        "GroupId": {"Fn::GetAtt": ["VPNServerSG", "GroupId"]}
      }
    },
    "SSManagerIngress": {
      "Type": "AWS::EC2::SecurityGroupIngress",
      "Condition": "EnableSSN",
      "Properties": {
        "IpProtocol": "udp",
        "FromPort": {"Ref": "SSManagerPort"},
        "ToPort": {"Ref": "SSManagerPort"},
        "CidrIp": "0.0.0.0/0",
        "GroupId": {"Fn::GetAtt": ["VPNServerSG", "GroupId"]}
      }
    },
    "SSMWebIngress": {
      "Type": "AWS::EC2::SecurityGroupIngress",
      "Condition": "EnableSSM",
      "Properties": {
        "IpProtocol": "tcp",
        "FromPort": {"Ref": "SSMPort"},
        "ToPort": {"Ref": "SSMPort"},
        "CidrIp": "0.0.0.0/0",
        "GroupId": {"Fn::GetAtt": ["VPNServerSG", "GroupId"]}
      }
    },
    "EIP": {
      "Type": "AWS::EC2::EIP",
      "Properties": {
        "Domain": {"Ref": "EipDomain"},
        "InstanceId": {"Ref": "VPNServerInstance"}
      }
    },
    "VPNServerInstance": {
      "Type": "AWS::EC2::Instance",
      "Properties": {
        "ImageId": {"Fn::FindInMap": ["RegionMap", {"Ref": "AWS::Region"}, "AMI"]},
        "InstanceType": {"Ref": "InstanceType"},
        "KeyName": {"Ref": "KeyPairName"},
        "Monitoring": {"Ref": "Monitoring"},
        "SubnetId": {"Fn::GetAtt": ["VpcStack", "Outputs.PublicSubnet01"]},
        "SecurityGroupIds": [{"Ref": "VPNServerSG"}],
        "BlockDeviceMappings": [
          {
            "DeviceName": "/dev/xvda",
            "Ebs": {
              "VolumeType": "gp2",
              "VolumeSize": "8"
            }
          }
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": {"Ref": "AWS::StackName"}
          },
          {"Fn::If": [
            "EnableSSN",
            {
              "Key": "Domain",
              "Value": {"Fn::Join": ["", [
                "{",
                "\"name\":\"", {"Ref": "SSDomain"},
                "\",\"nameserver\":\"", {"Ref": "SSDomainNameServer"},
                "\",\"user\":\"", {"Ref": "SSDomainUsername"},
                "\",\"credential\":\"", {"Ref": "SSDomainCredential"},
                "\"}"
              ]]}
            },
            {"Ref": "AWS::NoValue"}
          ]},
          {"Fn::If": [
            "EnableSSN",
            {
              "Key": "SSManager",
              "Value": {"Fn::Join": ["", [
                "{",
                "\"interface\":\"", {"Ref": "SSManagerInterface"},
                "\",\"port\":\"", {"Ref": "SSManagerPort"},
                "\",\"encrypt\":\"", {"Ref": "SSEncrypt"},
                "\",\"timeout\":\"", {"Ref": "SSTimeout"},
                "\",\"fastopen\":\"", {"Ref": "SSFastopen"},
                "\"}"
              ]]}
            },
            {"Ref": "AWS::NoValue"}
          ]},
          {"Fn::If": [
            "EnableSSN",
            {
              "Key": "SnsTopicArn",
              "Value": {"Ref": "SnsTopicForSsn"}
            },
            {"Ref": "AWS::NoValue"}
          ]},
          {"Fn::If": [
            "EnableSSN",
            {
              "Key": "AccessKeyForUserSnsPublisher",
              "Value": {"Ref": "AccessKeyForUserSnsPublisher"}
            },
            {"Ref": "AWS::NoValue"}
          ]},
          {"Fn::If": [
            "EnableSSN",
            {
              "Key": "SecretKeyForUserSnsPublisher",
              "Value": {"Fn::GetAtt": [
                "AccessKeyForUserSnsPublisher",
                "SecretAccessKey"
              ]}
            },
            {"Ref": "AWS::NoValue"}
          ]},
          {"Fn::If": [
            "EnableConfigConsumer",
            {
              "Key": "ConditionalDependsOn-LambdaSnsTopicSubscriberInvokePermission",
              "Value": {"Ref": "LambdaSnsTopicSubscriberInvokePermission"}
            },
            {"Ref": "AWS::NoValue"}
          ]},
          {"Fn::If": [
            "EnableConfigConsumer",
            {
              "Key": "ConditionalDependsOn-SnsTopicPolicyForConfig",
              "Value": {"Ref": "SnsTopicPolicyForConfig"}
            },
            {"Ref": "AWS::NoValue"}
          ]},
          {"Fn::If": [
            "EnableConfigProvider",
            {
              "Key": "ConditionalDependsOn-ConfigProviderStack",
              "Value": {"Ref": "ConfigProviderStack"}
            },
            {"Ref": "AWS::NoValue"}
          ]}
        ],
        "UserData": {
          "Fn::Base64": {
            "Fn::Join": [
              "",
              [
                "#!/bin/bash -x\n",
                "yum update -y aws-cfn-bootstrap\n",
                "# Install the files and packages from the metadata\n",
                "#/opt/aws/bin/cfn-init ",
                "#         --stack ", {"Ref": "AWS::StackName"},
                "#         --resource VPNServerInstance ",
                "#         --configsets InstallAndRun ",
                "#         --region ", {"Ref": "AWS::Region"}, "\n",

                "yum update -y\n",

                "yum install -y git\n",
                "export PATH=/usr/local/bin:$PATH\n",

                {"Fn::If": ["EnableSSN", {"Fn::Join": ["", [
                  "private_ip=$(curl http://169.254.169.254/latest/meta-data/local-ipv4)\n",
                  "git clone --depth 1 https://github.com/alexzhangs/aws-ec2-shadowsocks-libev\n",

                  "bash aws-ec2-shadowsocks-libev/install.sh",
                  " -m '", {"Ref": "SSEncrypt"}, "'",
                  " -t '", {"Ref": "SSTimeout"}, "'",
                  " -f '", {"Ref": "SSFastopen"}, "'",
                  " -s \"", {"Fn::If": ["SSMIFLocalhost", "127.0.0.1",
                                       {"Fn::If": ["SSMIFPrivate", "$private_ip",
                                                   {"Fn::If": ["SSMIFPublic", "0.0.0.0", ""]}
                                                  ]}
                                       ]}, "\"",
                  " -p '", {"Ref": "SSManagerPort"}, "'\n"
                ]]}, ""]},

                {"Fn::If": ["EnableSSM", {"Fn::Join": ["", [
                  "yum install -y rabbitmq-server --enablerepo=epel\n",
                  "chkconfig rabbitmq-server on\n",
                  "service rabbitmq-server start\n",

                  "yum install -y memcached\n",
                  "chkconfig memcached on\n",
                  "service memcached start\n",

                  "yum install -y nginx\n",
                  "chkconfig nginx on\n",
                  "nginx -t && service nginx start\n",

                  "git clone --depth 1 https://github.com/alexzhangs/aws-ec2-supervisor\n",
                  "bash aws-ec2-supervisor/aws-ec2-supervisor-install.sh -i -v 4.0.3\n",
                  "chkconfig supervisord on\n",
                  "service supervisord start\n",

                  "yum install -y gcc\n",
                  "pip install uwsgi==2.0.18\n",

                  "git clone --depth 1 https://github.com/alexzhangs/shadowsocks-manager\n",

                  "bash shadowsocks-manager/install.sh",
                  " -n '", {"Fn::If": ["SSMDomainIsNotNull", {"Ref": "SSMDomain"},
                                       {"Fn::If": ["SSDomainIsNotNull", {"Ref": "SSDomain"},
                                                   ""]}
                                      ]}, "'",
                  " -u '", {"Ref": "SSMAdminUsername"}, "'",
                  " -p '", {"Ref": "SSMAdminPassword"}, "'",
                  " -e '", {"Ref": "SSMAdminEmail"}, "'",
                  " -t '", {"Ref": "SSMTimeZone"}, "'",
                  " -r '", {"Ref": "SSPortBegin"}, "'",
                  " -R '", {"Ref": "SSPortEnd"}, "'\n",

                  "supervisorctl reload\n",
                  "service nginx reload\n"
                ]]}, ""]},

                {"Fn::If": ["EnableL2TP", {"Fn::Join": ["", [
                  "git clone --depth 1 https://github.com/alexzhangs/aws-ec2-xl2tpd\n",
                  "git clone --depth 1 https://github.com/alexzhangs/chap-manager\n",

                  "bash aws-ec2-xl2tpd/install.sh",
                  " -k '", {"Ref": "L2TPSharedKey"}, "'",
                  " -p '", {"Ref": "L2TPPrimaryDNS"}, "'",
                  " -s '", {"Ref": "L2TPSecondaryDNS"}, "'\n",

                  "bash chap-manager/install.sh\n",

                  "chap-manager.sh -a add",
                  " -u '", {"Ref": "L2TPUsername"}, "'",
                  " -p '", {"Ref": "L2TPPassword"}, "'\n"
                ]]}, ""]},

                "# Signal the status from cfn-init\n",
                "/opt/aws/bin/cfn-signal -e $?",
                " --stack ", {"Ref": "AWS::StackName"},
                " --resource VPNServerInstance",
                " --region ", {"Ref": "AWS::Region"}, "\n",

                {"Fn::If": ["EnableSSM", {"Fn::Join": ["", [
                  "# wait for EIP get ready.\n",
                  "sleep 60\n",
                  "# restart services to be aware of the EIP.\n",
                  "supervisorctl reload\n"
                ]]}, ""]}
              ]
            ]
          }
        }
      },
      "CreationPolicy": {
        "ResourceSignal": {
          "Timeout": "PT8M"
        }
      }
    },
    "LambdaSsmApiExecutionRole": {
      "Type": "AWS::IAM::Role",
      "Condition": "EnableSSM",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {"Service": ["lambda.amazonaws.com"]},
              "Action": ["sts:AssumeRole"]
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
          "arn:aws:iam::aws:policy/AmazonEC2ReadOnlyAccess"
        ],
        "Path": "/"
      }
    },
    "LambdaSsmApi": {
      "Type": "AWS::Lambda::Function",
      "Condition": "EnableSSM",
      "Properties": {
        "Description": "Provide the Lambda interface for the shadowsocks-manager REST APIs: Domain, Node and SSManager.",
        "Code": { "ZipFile": { "Fn::Join": [ "\n", [
          "_E='post'",
          "_D='get'",
          "_C=False",
          "_B='data'",
          "_A=None",
          "import os,json,boto3,botocore.vendored.requests as requests",
          "print('Loading function')",
          "def lambda_handler(event,context):",
          "    A='SSM_INSTANCE_LOGICAL_ID';print('Received event: '+json.dumps(event));ec2=Ec2Instance(os.getenv('SSM_STACK_ID'),os.getenv(A))",
          "    if ec2 is _A:raise Exception('{}: not found the EC2 instance'.format(os.getenv(A)))",
          "    print('wait here, the CREATE notification of config may come earlier.');ec2.wait_until_running();print('go on now.');BaseAPI.backend=Backend(host=ec2.public_ip_address or os.getenv('SSM_DOMAIN'),port=os.getenv('SSM_PORT'),user=os.getenv('SSM_ADMIN_USERNAME'),password=os.getenv('SSM_ADMIN_PASSWORD'));action=event['action'].lower();cls=globals()[event['model']]",
          "    if action=='list':insts=cls.list(**event.get('filter',{})or{});return[i.serialize()for i in insts]",
          "    elif action=='save':inst=cls(**event[_B]);inst.save(method=event.get('method'),fields=event.get('fields'));return inst.serialize()",
          "    else:raise ValueError('{}: invalid action.'.format(action))",
          "class Ec2Instance:",
          "    def __new__(self,stack_id,logical_id):",
          "        ec2=boto3.resource('ec2');insts=ec2.instances.filter(Filters=[dict(Name='tag:aws:cloudformation:stack-id',Values=[stack_id]),dict(Name='tag:aws:cloudformation:logical-id',Values=[logical_id])])",
          "        for inst in insts:return inst",
          "class Backend:",
          "    def __init__(self,host,port=80,schema='http',user=_A,password=_A):self.url='{schema}://{host}:{port}'.format(host=host,port=port,schema=schema);self.host=host;self.port=port;self.schema=schema;self.user=user;self.password=password;self.session=_A;self.authenticated=_C;self.csrftoken=_A",
          "    def call(self,*args,**kwargs):",
          "        if self.csrftoken and _B in kwargs:kwargs[_B]['csrfmiddlewaretoken']=self.csrftoken;kwargs.update({'headers':{'X-CSRFToken':self.csrftoken}})",
          "        print(args,kwargs);resp=self.session.request(*args,**kwargs)",
          "        if resp:self.csrftoken=self.session.cookies.get('csrftoken',_A)",
          "        print('{}: {}'.format(str(resp),resp.text));return resp",
          "    def authenticate(self,url):",
          "        print('authenticating');self.session=requests.session();resp=self.call(_D,url)",
          "        if resp:",
          "            resp=self.call(_E,url,timeout=5,data=dict(username=self.user,password=self.password,next='/'))",
          "            if resp:self.authenticated=True",
          "        return resp",
          "class BaseAPI:",
          "    path='/';auth_path=_A;backend=_A",
          "    @classmethod",
          "    def get_url(cls,id=_A,auth=_C):url=cls.backend.url+(cls.auth_path if auth else cls.path);return url+'{}/'.format(id)if id else url",
          "    @classmethod",
          "    def call(cls,*args,**kwargs):",
          "        if cls.auth_path and not cls.backend.authenticated:",
          "            if not cls.backend.authenticate(cls.get_url(auth=True)):print('failed to authenticate');return",
          "        resp=cls.backend.call(*args,**kwargs)",
          "        if resp is not _A:return resp.json()",
          "class BaseModel:",
          "    class API(BaseAPI):auth_path='/admin/login/'",
          "    def __init__(self,**kwargs):",
          "        A='id'",
          "        for (k,v) in kwargs.items():setattr(self,k,v)",
          "        if not A in self.__dict__:setattr(self,A,_A)",
          "    @classmethod",
          "    def list(cls,**kwargs):result=cls.API.call(_D,cls.API.get_url(),params=kwargs);return[cls(**item)for item in result or[]]",
          "    def save(self,method=_A,fields=_A):",
          "        if not method:method=_E if self.id is _A else'put'",
          "        result=self.API.call(method,self.API.get_url(self.id),data=self.serialize(fields=fields))",
          "        if result:self.__dict__.update(result)",
          "        return self",
          "    def serialize(self,fields=_A):",
          "        data={}",
          "        for (k,v) in self.__dict__.items():",
          "            if fields and k not in fields:continue",
          "            if isinstance(v,(int,str)):data[k]=v",
          "        return data",
          "class Domain(BaseModel):",
          "    class API(BaseModel.API):path='/domain/'",
          "class Node(BaseModel):",
          "    class API(BaseModel.API):path='/shadowsocks/node/'",
          "class SSManager(BaseModel):",
          "    class API(BaseModel.API):path='/shadowsocks/ssmanager/'"
        ] ] } },
        "Environment": {
          "Variables": {
            "SSM_STACK_ID": {"Ref": "AWS::StackId"},
            "SSM_INSTANCE_LOGICAL_ID": "VPNServerInstance",
            "SSM_DOMAIN": {"Ref": "SSMDomain"},
            "SSM_PORT": {"Ref": "SSMPort"},
            "SSM_ADMIN_USERNAME": {"Ref": "SSMAdminUsername"},
            "SSM_ADMIN_PASSWORD": {"Ref": "SSMAdminPassword"}
          }
        },
        "Handler": "index.lambda_handler",
        "Runtime": "python3.7",
        "Timeout": "10",
        "Role": {"Fn::GetAtt": ["LambdaSsmApiExecutionRole", "Arn"]}
      }
    },
    "LambdaSsmApiInvokePermission": {
      "Type": "AWS::Lambda::Permission",
      "Condition": "EnableSSM",
      "Properties": {
        "FunctionName": {"Fn::GetAtt": ["LambdaSsmApi", "Arn"]},
        "Action": "lambda:InvokeFunction",
        "Principal": "lambda.amazonaws.com",
        "SourceAccount": {"Ref": "AWS::AccountId"}
      }
    },
    "LambdaSnsTopicSubscriberExecutionRole": {
      "Type": "AWS::IAM::Role",
      "Condition": "EnableConfigConsumer",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {"Service": ["lambda.amazonaws.com"]},
              "Action": ["sts:AssumeRole"]
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
          "arn:aws:iam::aws:policy/AmazonSSMReadOnlyAccess",
          "arn:aws:iam::aws:policy/AmazonEC2ReadOnlyAccess"
        ],
        "Path": "/"
      }
    },
    "LambdaSnsTopicSubscriber": {
      "Type": "AWS::Lambda::Function",
      "Condition": "EnableConfigConsumer",
      "Properties": {
        "Description": "Receive AWS Config events through SNS, and update Domain, Node and SSManager in shadowsocks-manager.",
        "Code": {
          "S3Bucket": {"Ref": "S3BucketForLambdaSnsTopicSubscriber"},
          "S3Key": {"Ref": "S3KeyForLambdaSnsTopicSubscriber"}
        },
        "Environment": {
          "Variables": {
            "SSM_STACK_ID": {"Ref": "AWS::StackId"},
            "SSM_INSTANCE_LOGICAL_ID": "VPNServerInstance",
            "SSM_DOMAIN": {"Ref": "SSMDomain"},
            "SSM_PORT": {"Ref": "SSMPort"},
            "SSM_ADMIN_USERNAME": {"Ref": "SSMAdminUsername"},
            "SSM_ADMIN_PASSWORD": {"Ref": "SSMAdminPassword"}
          }
        },
        "Handler": "LambdaSnsTopicSubscriber.lambda_handler",
        "Runtime": "python2.7",
        "Timeout": "60",
        "Role": {"Fn::GetAtt": ["LambdaSnsTopicSubscriberExecutionRole", "Arn"]}
      }
    },
    "LambdaSnsTopicSubscriberInvokePermission": {
      "Type": "AWS::Lambda::Permission",
      "Condition": "EnableConfigConsumer",
      "Properties": {
        "FunctionName": {"Fn::GetAtt": ["LambdaSnsTopicSubscriber", "Arn"]},
        "Action": "lambda:InvokeFunction",
        "Principal": "sns.amazonaws.com",
        "SourceArn": {"Ref": "SnsTopicForConfig"}
      }
    },
    "SnsTopicForConfig": {
      "Type": "AWS::SNS::Topic",
      "Condition": "EnableConfigConsumer",
      "Properties": {
        "TopicName": {"Fn::Sub": "${AWS::StackName}-config-topic"},
        "Subscription": [
          {
            "Endpoint": {"Fn::GetAtt": ["LambdaSnsTopicSubscriber", "Arn"]},
            "Protocol": "lambda"
          }
        ]
      }
    },
    "SnsTopicPolicyForConfig": {
      "Type": "AWS::SNS::TopicPolicy",
      "Condition": "EnableConfigConsumer",
      "Properties": {
        "PolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {"AWS": "*"},
              "Action": "sns:Publish",
              "Resource": {"Ref": "SnsTopicForConfig"}
            }
          ]
        },
        "Topics": [{"Ref": "SnsTopicForConfig"}]
      }
    },
    "UserSnsPublisher": {
      "Type": "AWS::IAM::User",
      "Properties": {
        "UserName": "sns_publisher",
        "Policies": [
          {
            "PolicyName": "policygen-SNS-PUBLISHER",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": "sns:Publish",
                  "Resource": {"Ref":"SnsTopicForSsn"}
                }
              ]
            }
          }
        ]
      }
    },
    "AccessKeyForUserSnsPublisher": {
      "Type": "AWS::IAM::AccessKey",
      "Properties": {
        "UserName": {
          "Ref": "UserSnsPublisher"
        }
      }
    },
    "SsnLambdaSnsTopicSubscriberExecutionRole": {
      "Type": "AWS::IAM::Role",
      "Condition": "EnableSSN",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {"Service": ["lambda.amazonaws.com"]},
              "Action": ["sts:AssumeRole"]
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
          "arn:aws:iam::aws:policy/AdministratorAccess"
        ],
        "Path": "/"
      }
    },
    "SsnLambdaSnsTopicSubscriber": {
      "Type": "AWS::Lambda::Function",
      "Condition": "EnableSSN",
      "Properties": {
        "Description": "Maintain the node stack by receiving the SNS messages.",
        "Code": {
          "S3Bucket": {"Ref": "S3BucketForSsnLambdaSnsTopicSubscriber"},
          "S3Key": {"Ref": "S3KeyForSsnLambdaSnsTopicSubscriber"}
        },
        "Environment": {
          "Variables": {
            "SSN_STACK_ID": {"Ref": "AWS::StackId"}
          }
        },
        "Handler": "SsnLambdaSnsTopicSubscriber.lambda_handler",
        "Runtime": "python2.7",
        "Timeout": "60",
        "Role": {"Fn::GetAtt": ["SsnLambdaSnsTopicSubscriberExecutionRole", "Arn"]}
      }
    },
    "SsnLambdaSnsTopicSubscriberInvokePermission": {
      "Type": "AWS::Lambda::Permission",
      "Condition": "EnableSSN",
      "Properties": {
        "FunctionName": {"Fn::GetAtt": ["SsnLambdaSnsTopicSubscriber", "Arn"]},
        "Action": "lambda:InvokeFunction",
        "Principal": "sns.amazonaws.com",
        "SourceArn": {"Ref": "SnsTopicForSsn"}
      }
    },
    "SnsTopicForSsn": {
      "Type": "AWS::SNS::Topic",
      "Condition": "EnableSSN",
      "Properties": {
        "TopicName": {"Fn::Sub": "${AWS::StackName}-ssn-topic"},
        "Subscription": [
          {
            "Endpoint": {"Fn::GetAtt": ["SsnLambdaSnsTopicSubscriber", "Arn"]},
            "Protocol": "lambda"
          }
        ]
      }
    },
    "SnsTopicPolicyForSsn": {
      "Type": "AWS::SNS::TopicPolicy",
      "Condition": "EnableSSN",
      "Properties": {
        "PolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {"AWS": "*"},
              "Action": "sns:Publish",
              "Resource": {"Ref": "SnsTopicForSsn"}
            }
          ]
        },
        "Topics": [{"Ref": "SnsTopicForSsn"}]
      }
    },
    "LambdaLexBotExecutionRole": {
      "Type": "AWS::IAM::Role",
      "Condition": "EnableLexBot",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {"Service": ["lambda.amazonaws.com"]},
              "Action": ["sts:AssumeRole"]
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        ],
        "Policies": [
          {
            "PolicyName": "default",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "lambda:InvokeFunction"
                  ],
                  "Resource": "*"
                }
              ]
            }
          }
        ],
        "Path": "/"
      }
    },
    "LambdaLexBot": {
      "Type": "AWS::Lambda::Function",
      "Condition": "EnableLexBot",
      "Properties": {
        "Description": "A chat bot to manage the stack.",
        "Code": { "ZipFile": { "Fn::Join": [ "\n", [
          "_M='PlainText'",
          "_L='content'",
          "_K='contentType'",
          "_J='isValid'",
          "_I='type'",
          "_H='dialogAction'",
          "_G='slots'",
          "_F='name'",
          "_E='VpnInstanceName'",
          "_D='message'",
          "_C='currentIntent'",
          "_B=None",
          "_A='sessionAttributes'",
          "import os,logging,json,boto3",
          "logger=logging.getLogger()",
          "logger.setLevel(logging.DEBUG)",
          "def call_ssm(**C):",
          "    D=boto3.client('lambda');A=D.invoke(FunctionName=os.getenv('LAMBDA_SSM_API_ARN'),Payload=json.dumps(C))",
          "    if A['StatusCode']>=400:raise Exception('Failed to call the Lambda of SSM API. Response: '+A)",
          "    B=json.load(A['Payload'])",
          "    if B and isinstance(B,dict) and B.get('errorMessage'):return _B",
          "    return B",
          "def get_slots(intent_request):return intent_request[_C][_G]",
          "def elicit_slot(session_attributes,intent_name,slots,slot_to_elicit,message):return{_A:session_attributes,_H:{_I:'ElicitSlot','intentName':intent_name,_G:slots,'slotToElicit':slot_to_elicit,_D:message}}",
          "def close(session_attributes,fulfillment_state,message):A={_A:session_attributes,_H:{_I:'Close','fulfillmentState':fulfillment_state,_D:message}};return A",
          "def delegate(session_attributes,slots):return{_A:session_attributes,_H:{_I:'Delegate',_G:slots}}",
          "def build_validation_result(is_valid,violated_slot,message_content):",
          "    D='violatedSlot';C=message_content;B=violated_slot;A=is_valid",
          "    if C is _B:return{_J:A,D:B}",
          "    return{_J:A,D:B,_D:{_K:_M,_L:C}}",
          "def get_instances():return call_ssm(action='list',model='Node',filter=_B)",
          "def get_sns_endpoint(instance):",
          "    for A in get_instances()or[]:",
          "        if instance.lower==A.name.lower():return A['sns_endpoint']",
          "def validate_instance(instance):",
          "    A=instance;B=[A.name.lower()for A in get_instances()or[]]",
          "    if A.lower()not in B:return build_validation_result(False,_E,'{}: the instance name you specified does not exist, the valid instance names are: {}.'.format(A,','.join(B)))",
          "    return build_validation_result(True,_B,_B)",
          "def change_ip(intent_request):",
          "    A=intent_request;C=get_slots(A);B=C[_E];F=A['invocationSource']",
          "    if F=='DialogCodeHook':",
          "        if not B:return elicit_slot(A[_A],A[_C][_F],C,_E,_B)",
          "        E=validate_instance(B)",
          "        if not E[_J]:return elicit_slot(A[_A],A[_C][_F],C,_E,E[_D])",
          "    D=get_sns_endpoint(B)",
          "    if not D:return close(A[_A],'Failed',{_K:_M,_L:'{}: not found the SNS endpoint on this instance.'.format(B)})",
          "    G=boto3.resource('sns');H=G.Topic(D);H.publish(TargetArn=D,Message='change_ip');return close(A[_A],'Fulfilled',{_K:_M,_L:'The IP address of instance {} will be replaced with a new one.'.format(B)})",
          "def dispatch(intent_request):",
          "    A=intent_request;logger.debug('dispatch userId={}, intentName={}'.format(A['userId'],A[_C][_F]));B=A[_C][_F]",
          "    if B=='GetNewIpForVpnInstance':return change_ip(A)",
          "    raise Exception('Intent with name '+B+' not supported')",
          "def lambda_handler(event,context):A=event;logger.info('Received event'+json.dumps(A));return dispatch(A)"
        ] ] } },
        "Environment": {
          "Variables": {
            "LAMBDA_SSM_API_ARN": {"Fn::GetAtt": ["LambdaSsmApi", "Arn"]}
          }
        },
        "Handler": "index.lambda_handler",
        "Runtime": "python3.7",
        "Timeout": "10",
        "Role": {"Fn::GetAtt": ["LambdaLexBotExecutionRole", "Arn"]}
      }
    },
    "LambdaLexBotInvokePermission": {
      "Type": "AWS::Lambda::Permission",
      "Condition": "EnableLexBot",
      "Properties": {
        "FunctionName": {"Fn::GetAtt": ["LambdaLexBot", "Arn"]},
        "Action": "lambda:InvokeFunction",
        "Principal": {"Fn::If": [
          "LexBotSeparateRegion",
          "lambda.amazonaws.com",
          "lex.amazonaws.com"
        ]},
        "SourceAccount": {"Ref": "AWS::AccountId"}
      }
    }
  },
  "Conditions": {
    "EnableVpcPeerAccepter": {
      "Fn::Equals": [{"Ref": "EnableVpcPeerAccepter"}, "1"]
    },
    "EnableVpcPeerRequester": {
      "Fn::Equals": [{"Ref": "EnableVpcPeerRequester"}, "1"]
    },
    "EnableSSN": {
      "Fn::Equals": [{"Ref": "EnableSSN"}, "1"]
    },
    "EnableSSM": {
      "Fn::Equals": [{"Ref": "EnableSSM"}, "1"]
    },
    "EnableL2TP": {
      "Fn::Equals": [{"Ref": "EnableL2TP"}, "1"]
    },
    "EnableConfigConsumer": {
      "Fn::Equals": [{"Ref": "EnableConfigConsumer"}, "1"]
    },
    "EnableConfigProvider": {
      "Fn::Equals": [{"Ref": "EnableConfigProvider"}, "1"]
    },
    "EnableLexBot": {
      "Fn::Equals": [{"Ref": "EnableLexBot"}, "1"]
    },
    "LexBotSeparateRegion": {
      "Fn::Not": [{
        "Fn::Equals": [{"Ref": "AWS::Region"}, {"Ref": "LexBotRegion"}]
      }]
    },
    "SSMDomainIsNotNull": {
      "Fn::Not": [{"Fn::Equals":["", {"Ref": "SSMDomain"}]}]
    },
    "SSDomainIsNotNull": {
      "Fn::Not": [{"Fn::Equals":["", {"Ref": "SSDomain"}]}]
    },
    "SSMIFLocalhost": {
      "Fn::Equals": [{"Ref": "SSManagerInterface"}, "1"]
    },
    "SSMIFPrivate": {
      "Fn::Equals": [{"Ref": "SSManagerInterface"}, "2"]
    },
    "SSMIFPublic": {
      "Fn::Equals": [{"Ref": "SSManagerInterface"}, "3"]
    }
  },
  "Parameters": {
    "VpcCidrBlock": {
      "Type": "String",
      "Default": "10.0.0.0/16",
      "Description": "Enter CIDR Block for VPC. Default is '10.30.0.0/16' (65536 IPs).",
      "MinLength": "9",
      "MaxLength": "18",
      "AllowedPattern": "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})",
      "ConstraintDescription": "Must be a valid IP CIDR range of the form x.x.x.x/x."
    },
    "EnableVpcPeerAccepter": {
      "Type": "String",
      "Default": "0",
      "AllowedValues": ["0", "1"],
      "Description": "Whether to create VPC peer accepter resource. 0: no, 1: yes. Default is '0'."
    },
    "VpcPeerAccepterStackTemplateURL": {
      "Type": "String",
      "Default": "",
      "Description": "VPC peer accepter stack template URL, must be an AWS S3 URL."
    },
    "EnableVpcPeerRequester": {
      "Type": "String",
      "Default": "0",
      "AllowedValues": ["0", "1"],
      "Description": "Whether to create VPC peer requester resource. 0: no, 1: yes. Default is '0'."
    },
    "VpcPeerRequesterStackTemplateURL": {
      "Type": "String",
      "Default": "",
      "Description": "VPC peer requester stack template URL, must be an AWS S3 URL."
    },
    "VpcPeerAccepterVpcId": {
      "Type": "String",
      "Default": "",
      "Description": "VPC ID of the VPC peer accepter."
    },
    "VpcPeerAccepterRegion": {
      "Type": "String",
      "Default": "",
      "Description": "Region code of the VPC peer accepter."
    },
    "VpcPeerAccepterRoleArn": {
      "Type": "String",
      "Default": "",
      "Description": "Amazon Resource Name (ARN) of the VPC peer role of accepter."
    },
    "VpcPeerAccepterCidrBlock": {
      "Type": "String",
      "Default": "10.0.0.0/16",
      "Description": "CIDR Block of the VPC peer accepter.",
      "MinLength": "9",
      "MaxLength": "18",
      "AllowedPattern": "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})",
      "ConstraintDescription": "Must be a valid IP CIDR range of the form x.x.x.x/x."
    },
    "VpcPeerAccepterSqsQueueUrl": {
      "Type": "String",
      "Default": "",
      "Description": "SQS queue URL of the VPC peer accepter."
    },
    "SubnetCidrBlocks": {
      "Type": "CommaDelimitedList",
      "Default": "10.0.0.0/24, 10.0.1.0/24, 10.0.2.0/24, 10.0.3.0/24",
      "Description": "Comma-delimited list of CIDR blocks for subnets. Default is '10.30.0.0/24, 10.30.1.0/24, 10.30.2.0/24, 10.30.3.0/24' (256 IPs each).",
      "ConstraintDescription": "The single CIDR block must be a valid IP CIDR range of the form x.x.x.x/x."
    },
    "EipDomain": {
      "Type": "String",
      "Default": "vpc",
      "Description": "Switch the value between '' and 'vpc' to refresh EIP. The EIP assigned out of stack won't be deleted on stack delete. Default is 'vpc'."
    },
    "InstanceType": {
      "Type": "String",
      "Default": "t2.micro",
      "Description": "Enter a Instance Type. Default is 't2.micro'."
    },
    "Monitoring": {
      "Type": "String",
      "Default": "false",
      "Description": "Enter mornitor status. Default is 'false'."
    },
    "KeyPairName": {
      "Type": "AWS::EC2::KeyPair::KeyName",
      "Default": "myhosts",
      "Description": "Enter Key Pair name. Default is 'myhosts'"
    },
    "EnableSSN": {
      "Type": "String",
      "Default": "1",
      "AllowedValues": ["0", "1"],
      "Description": "Whether to install Shadowsocks server. 0: no, 1: yes. Default is '1'."
    },
    "SnsTopicArn": {
      "Type": "String",
      "Default": "",
      "Description": "Amazon Resource Name (ARN) of SNS topic."
    },
    "EnableSSM": {
      "Type": "String",
      "Default": "1",
      "AllowedValues": ["0", "1"],
      "Description": "Whether to install Shadowsocks manager. 0: no, 1: yes. Default is '1'."
    },
    "EnableL2TP": {
      "Type": "String",
      "Default": "1",
      "AllowedValues": ["0", "1"],
      "Description": "Whether to install L2TP server. 0: no, 1: yes. Default is '1'."
    },
    "SSPortBegin": {
      "Type": "String",
      "Default": "8381",
      "AllowedPattern": "\\d{1,5}",
      "Description": "Begin port allowed to use for Shadowsocks server. Default is '8381'."
    },
    "SSPortEnd": {
      "Type": "String",
      "Default": "8480",
      "AllowedPattern": "\\d{1,5}",
      "Description": "End port allowed to use for Shadowsocks server. Default is '8480'."
    },
    "SSDomain": {
      "Type": "String",
      "Default": "",
      "Description": "Domain name resolved to Shadowsocks server. Example: vpn.yourdomain.com"
    },
    "SSDomainNameServer": {
      "Type": "String",
      "Default": "",
      "Description": "Nameserver for the domain. Supported values: ['name.com']."
    },
    "SSDomainUsername": {
      "Type": "String",
      "Default": "",
      "Description": "User identity for the Nameserver API service."
    },
    "SSDomainCredential": {
      "Type": "String",
      "Default": "",
      "NoEcho": "true",
      "Description": "User credential/token for the Nameserver API service."
    },
    "SSManagerInterface": {
      "Type": "String",
      "Default": "1",
      "Description": "Network interface bound to Shadowsocks Manager API on the node. 1: Localhost, 2: Private, 3: Public. Default is 1"
    },
    "SSManagerPort": {
      "Type": "String",
      "Default": "6001",
      "Description": "Port number bound to Shadowsocks Manager API. Default is 6001"
    },
    "SSEncrypt": {
      "Type": "String",
      "Default": "aes-256-gcm",
      "Description": "Encrypt method for Shadowsocks server. Default is 'aes-256-gcm'."
    },
    "SSTimeout": {
      "Type": "String",
      "Default": "60",
      "AllowedPattern": "\\d{1,3}",
      "Description": "Socket timeout in seconds for Shadowsocks server. Default is 60."
    },
    "SSFastopen": {
      "Type": "String",
      "Default": "false",
      "Description": "Enable TCP fast open for Shadowsocks server. Default is 'false'."
    },
    "SSMAccountId": {
      "Type": "String",
      "Default": "",
      "Description": "AWS Account ID of the owner of the Shadowsocks manager stack."
    },
    "SSMDomain": {
      "Type": "String",
      "Default": "",
      "Description": "Domain Name resolved to Shadowsocks manager. Set this if don't want to use the same with Shadowsocks server. Example: vpn-admin.yourdomain.com."
    },
    "SSMPort": {
      "Type": "String",
      "Default": "8000",
      "Description": "Port number bound to Shadowsocks manager. Default is 8000"
    },
    "SSMAdminUsername": {
      "Type": "String",
      "Default": "admin",
      "Description": "Username for Shadowsocks manager administrator. Default is 'admin'."
    },
    "SSMAdminPassword": {
      "Type": "String",
      "Default": "passw0rd",
      "NoEcho": "true",
      "Description": "Password for Shadowsocks manager administrator. Default is 'passw0rd'."
    },
    "SSMAdminEmail": {
      "Type": "String",
      "Default": "",
      "Description": "Email address for Shadowsocks manager administrator. Will be shown as contact in account notification Email."
    },
    "SSMTimeZone": {
      "Type": "String",
      "Default": "UTC",
      "Description": "Prefered Time Zone. Default is 'UTC'."
    },
    "L2TPUsername": {
      "Type": "String",
      "Default": "vpnuser",
      "Description": "Enter username. Default is 'vpnuser'."
    },
    "L2TPPassword": {
      "Type": "String",
      "Default": "passw0rd",
      "NoEcho": "true",
      "Description": "Password to connecting to L2TP server. Default is 'passw0rd'."
    },
    "L2TPSharedKey": {
      "Type": "String",
      "Default": "SharedSecret",
      "NoEcho": "true",
      "Description": "Enter IPSec PSK. Default is 'SharedSecret'."
    },
    "L2TPPrimaryDNS": {
      "Type": "String",
      "Default": "8.8.8.8",
      "MinLength": "7",
      "MaxLength": "15",
      "AllowedPattern": "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})",
      "ConstraintDescription": "Must be a valid IP v4 address like x.x.x.x.",
      "Description": "Enter primary DNS. Default is '8.8.8.8'."
    },
    "L2TPSecondaryDNS": {
      "Type": "String",
      "Default": "8.8.4.4",
      "MinLength": "7",
      "MaxLength": "15",
      "AllowedPattern": "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})",
      "ConstraintDescription": "Must be a valid IP v4 address like x.x.x.x.",
      "Description": "Enter primary DNS. Default is '8.8.4.4'."
    },
    "EnableConfigConsumer": {
      "Type": "String",
      "Default": "0",
      "AllowedValues": ["0", "1"],
      "Description": "Specifies whether SNS topic and Lambda function should be created, to handle the change events of AWS Config services. If you set EnableSSM=1, then you should set this option to '1'. The default is '0'."
    },
    "EnableConfigProvider": {
      "Type": "String",
      "Default": "0",
      "AllowedValues": ["0", "1"],
      "Description": "Specifies whether AWS Config services should be set up to notify EC2 instance changes so that the instance can be auto-registered into Shadowsocks manager. If you set EnableSSN=1, then you should set this option to '1', but only set once in one AWS account. If you have already set up AWS Config in the account, then set this option to '0'. The default is '0'."
    },
    "ConfigProviderStackTemplateURL": {
      "Type": "String",
      "Default": "",
      "Description": "Config Provider stack template URL, must be an AWS S3 URL."
    },
    "EnableLexBot": {
      "Type": "String",
      "Default": "0",
      "AllowedValues": ["0", "1"],
      "Description": "Specifies whether Amazon Lex Bot should be set up so that a chat interface can be used to manage Shadowsocks manager and node stacks. If you set EnableSSM=1, then you could set this option to '1'. The default is '0'."
    },
    "LexBotStackTemplateURL": {
      "Type": "String",
      "Default": "",
      "Description": "Lex Bot stack template URL, must be an AWS S3 URL."
    },
    "LexBotRegion": {
      "Type": "String",
      "Default": "",
      "Description": "Region name to deploy the Lex Bot stack, leave blank to deploy the Lex Bot in the default region."
    },
    "VpcStackTemplateURL": {
      "Type": "String",
      "Default": "",
      "Description": "VPC stack template URL, must be an AWS S3 URL."
    },
    "S3BucketForLambdaSnsTopicSubscriber": {
      "Type": "String",
      "Default": "",
      "Description": "S3 bucket name for LambdaSnsTopicSubscriber."
    },
    "S3KeyForLambdaSnsTopicSubscriber": {
      "Type": "String",
      "Default": "",
      "Description": "S3 key for LambdaSnsTopicSubscriber."
    },
    "S3BucketForSsnLambdaSnsTopicSubscriber": {
      "Type": "String",
      "Default": "",
      "Description": "S3 bucket name for SsnLambdaSnsTopicSubscriber."
    },
    "S3KeyForSsnLambdaSnsTopicSubscriber": {
      "Type": "String",
      "Default": "",
      "Description": "S3 key for SsnLambdaSnsTopicSubscriber."
    }
  },
  "Mappings": {
    "RegionMap": {
      "ap-east-1": {
        "endpoint": "rds.ap-east-1.amazonaws.com",
        "location": "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        "AMI": "ami-29160d47",
        "endpoint": "rds.ap-northeast-1.amazonaws.com",
        "location": "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        "AMI": "ami-983ce8f6",
        "endpoint": "rds.ap-northeast-2.amazonaws.com",
        "location": "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        "endpoint": "rds.ap-northeast-3.amazonaws.com",
        "location": "Asia Pacific (Osaka-Local)"
      },
      "ap-south-1": {
        "endpoint": "rds.ap-south-1.amazonaws.com",
        "location": "Asia Pacific (Mumbai)"
      },
      "ap-southeast-1": {
        "AMI": "ami-1ddc0b7e",
        "endpoint": "rds.ap-southeast-1.amazonaws.com",
        "location": "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        "endpoint": "rds.ap-southeast-2.amazonaws.com",
        "location": "Asia Pacific (Sydney)"
      },
      "ca-central-1": {
        "endpoint": "rds.ca-central-1.amazonaws.com",
        "location": "Canada (Central)"
      },
      "cn-north-1": {
        "endpoint": "rds.cn-north-1.amazonaws.com.cn",
        "location": "China (Beijing)"
      },
      "cn-northwest-1": {
        "endpoint": "rds.cn-northwest-1.amazonaws.com.cn",
        "location": "China (Ningxia)"
      },
      "eu-central-1": {
        "endpoint": "rds.eu-central-1.amazonaws.com",
        "location": "EU (Frankfurt)"
      },
      "eu-north-1": {
        "AMI": "ami-05a66c68",
        "endpoint": "rds.eu-north-1.amazonaws.com",
        "location": "EU (Stockholm)"
      },
      "eu-west-1": {
        "endpoint": "rds.eu-west-1.amazonaws.com",
        "location": "EU (Ireland)"
      },
      "eu-west-2": {
        "endpoint": "rds.eu-west-2.amazonaws.com",
        "location": "EU (London)"
      },
      "eu-west-3": {
        "endpoint": "rds.eu-west-3.amazonaws.com",
        "location": "EU (Paris)"
      },
      "sa-east-1": {
        "endpoint": "rds.sa-east-1.amazonaws.com",
        "location": "South America (São Paulo)"
      },
      "us-east-1": {
        "endpoint": "rds.us-east-1.amazonaws.com",
        "location": "US East (N. Virginia)"
      },
      "us-east-2": {
        "endpoint": "rds.us-east-2.amazonaws.com",
        "location": "US East (Ohio)"
      },
      "us-gov-east-1": {
        "endpoint": "rds.us-gov-east-1.amazonaws.com",
        "location": "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        "endpoint": "rds.us-gov-west-1.amazonaws.com",
        "location": "AWS GovCloud (US)"
      },
      "us-west-1": {
        "endpoint": "rds.us-west-1.amazonaws.com",
        "location": "US West (N. California)"
      },
      "us-west-2": {
        "AMI": "ami-08d489468314a58df",
        "endpoint": "rds.us-west-2.amazonaws.com",
        "location": "US West (Oregon)"
      }
    }
  },
  "Outputs": {
    "AccountId": {
      "Value": {"Ref": "AWS::AccountId"}
    },
    "VpcId": {
      "Value": {"Fn::GetAtt": ["VpcStack", "Outputs.Vpc"]}
    },
    "SnsTopicArnForConfig": {
      "Condition": "EnableConfigConsumer",
      "Value": {"Ref": "SnsTopicForConfig"}
    },
    "SnsTopicArnForSsn": {
      "Condition": "EnableSSN",
      "Value": {"Ref": "SnsTopicForSsn"}
    },
    "LambdaLexBotArn": {
      "Condition": "EnableLexBot",
      "Value": {"Fn::GetAtt": ["LambdaLexBot", "Arn"]}
    },
    "IamPeerRoleArn": {
      "Condition": "EnableVpcPeerAccepter",
      "Value": {"Fn::GetAtt": ["VpcPeerAccepterStack", "Outputs.IamPeerRoleArn"]}
    },
    "VpcPeerAccepterSqsQueueUrl": {
      "Condition": "EnableVpcPeerAccepter",
      "Value": {"Fn::GetAtt": ["VpcPeerAccepterStack", "Outputs.SqsPeerRouteQueueUrl"]}
    },
    "SecurityGroupId": {
      "Value": {"Ref": "VPNServerSG"}
    },
    "InstanceId": {
      "Value": {"Ref": "VPNServerInstance"}
    },
    "PublicIp": {
      "Value": {"Fn::GetAtt": ["VPNServerInstance", "PublicIp"]}
    },
    "PrivateIp": {
      "Value": {"Fn::GetAtt": ["VPNServerInstance", "PrivateIp"]}
    }
  }
}
